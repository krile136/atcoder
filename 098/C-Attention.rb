n = gets.strip.to_i
s = gets.strip.split('')

# 数字を入れる配列を用意する
r = []
l = []
r_c = (1..n+1).map{|i| i = 0 }
l_c = (1..n+1).map{|i| i = 0 }

# 数字と累積和の配列を生成
(1..n).each do |i|
  if s[i-1] == "E"
    r[i-1] = 1
    l[i-1] = 0
  else
    r[i-1] = 0
    l[i-1] = 1
  end
  r_c[i] = r_c[i-1] + r[i-1]
  l_c[i] = l_c[i-1] + l[i-1]
end

# 最小の回数を計算する
min = n
(1..n).each do |i|
  count = ( l_c[i] - l_c[0] ) + ( r_c[n] - r_c[i-1] ) - 1
  min = count if count < min
end
puts min 


# アルゴリズム説明
# 以下の配列を作る
# r：東を見ている人を1、西を向いている人を0
# l：東を見ている人を0、西を向いている人を1
# r_c：rの累積和の配列
# l_c：lの累積和の配列
# 条件が以下の時、それぞれの配列は以下のようになる
# 12
# WEWEWEEEWWWE
# 各配列
# r   :010101110001
# r_c :0011223455556
# l   :101010001110
# l_c :0112233334566
# iの位置の時、iよりも左にいるメンバーを右向きにする回数は
# l_c[i] - l_c[0]
# iよりも右にいるメンバーを左向きにする回数は
# r_c[n] - r_c[i-1]
# この二つを足し合わせるが、ちょうどi番目を振り向かせる回数が
# どちらかで 1 足されているので、最後に1を引くと合計の振り向かせる回数となる
# それの最小値をとっている